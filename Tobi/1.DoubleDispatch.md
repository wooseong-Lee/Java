<h1>Double Dispatch</h1>

<strong>관련 내용: </strong>Visitor Pattern, ,Visitor Proxy Pattern(Principle of Hibernate)

<h2>(Method)Dispatch</h2>

- 어떤 메소드를 실행할 것 인지를 결정한 뒤, 실행하는 것!

<h2>Static dispatch</h2>

<strong>컴파일되는 시점에 어떤 메소드가 실행될지 알 고 있는 것</strong>

<br/>
<br/>

아래의 경우 <strong>컴파일 시점</strong>에도 어떤 메소드가 실행될지 알 고 있으며, 따라서 컴파일된 바이트코드에도 해당 정보가 남아있다. 오버로딩되서 이름이 같지만, 사실상 전혀 다른 메소드라고 생각하고 런타임시에 자유롭게 호출할 수 있다.

~~~
public static Dispatch {
    static class Service {
        void run(int number) {
            System.out.println("run(" + number + ")");
        }

        void run(String msg) {
            System.out.println("run(" + msg + ")");
        }
    }

    public static void main(String[] args) {
        new Service().run(1);
        new Service().run("Dispatch");
    }
}
~~~

<h2>Dynamic dispatch</h2>

아래의 경우에 두 개의 run 메소드 중 어떤 메소드가 호출될 지 컴파일 시점에 결정되있지 않다. 

~~~
public static Dispatch {
    static abstract class Service {
        abstract void run();
    }

    static class MyService1 extends Service {
        @Override
        void run() {
            System.out.println("run1");
        }
    }

    static class MyService2 extends Service {
        @Override
        void run() {
            System.out.println("run2");
        }
    }

    public static void main(String[] args) {
        Service svc = new MyService1();

        svc.run();
    }
}
~~~

런타임 시점에 svc에 할당되있는 객체가 뭔지 확인한 뒤, 그걸 기준으로 런타임 시에 호출한다.

<br/>
<br/>

**Receiver parameter: 인스턴스 메소드 호출 시 첫번 째 파라미터로 (자동으로)this를 넘겨준다. 따라서 this가 어떤 객체를 참조하고 있는지에 따라 호출되는 메소드가 결정된다!**

<br/>
<br/>

아래의 예에서 한번은 MyService1를 참조하는 this, 한번은 MyService2를 참조하는 this가 넘어가면서 객체가 생성된다.

~~~
List<Service> services = List.of(new MyService1(), new MyService2());
services.forEach(Service::run);
~~~

<h4>Method Signature vs Method Type</h4>

- Method Signature: name, parameter types and list

**Method Signature에 return type은 포함되지 않으며, 시그니처가 동일한 메소드는 한 클래스내에 정의가 될 수 없다. 따라서 메소드 오버로딩의 기준은 메소드 시그니처가 된다.**

- Method Type: return type, method argument types, method type parameter, exceptions(name은 포함되지 않는다.)

**Method Type이 동일하면 Method reference를 사용할 수 있다.**

<br/>
<br/>

