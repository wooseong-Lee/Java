<h1>실행</h1>
자바 애플리케이션은 java 명령어로 실행할 수 있다.

~~~
java 명령어는 자바 애플리케이션을 실행한다.
java 명령어는 먼저 JRE(Java Runtime Environment)를 시작하고, 인자로 지정된 클래스(public static void main(String[]args)를 포함하고 있는 클래스)를 로딩하고, main()메소드를 실행한다.
~~~

<h2>JRE 시작</h2>

java 명령 실행에 의해 JRE가 시작된다는 것은 java 명령어의 인자로 지정된 클래스를 실행하기 위한 자바 실행 환경이 조성됨을 의미한다. java 명령어의 인자로 지정한 설정 옵션에 맞게 JVM이 실행되고 JVM이 클래스 로더를 이용해서 initial class를 create하고, initial class를 link하고 initialize하고, main 메소드를 실행한다.

- initial class: JVM 구현에 따라 다를 수 있지만, 일반적으로 main 메소드를 포함하는 클래스로서 java 명령어의 인자로 지정되는 클래스(BootStrap Class Loader가 로딩해준다.)
- create: 해당 클래스나 인터페이스의 바이트 코드를 로딩해서 JVM이 할당한 메모리(Method Area)에 Contruction하는 것.
- link(a class or interface): 해당 클래스나 인터페이스의 바로 위 수퍼클래스나 수퍼인터페이스, 또는 배열일 경우 배열의 원소인 클래스나 인터페이스를 확인(verify)/ 준비(prepare)하고, 심볼릭 참조를 해석(resolve)해서 JVM에서 실행할 수 있는 상태로 만드는 것.
- initialize(a class or interface): 해당 클래스나 인터페이스의 initialization method를 실행하는 것.
- load: 해당 클래스나 인터페이스의 바이너리 표현을 찾아서 그 바이너리 표현으로부터 클래스나 인퍼헤이스를 생성하는 것(create)

<h2>Runtime Data Area</h2>

![RuntimeDataArea](images/RuntimeDataArea.png)

여기서 '단위'라는 구분 단계를 추가한 이유는 스펙에도 per-class, per-thread라는 표현이 나오기 떄문인데, 여기에서 '단위'는 생명 주기와 생성 단위를 의미한다.
<strong>JVM단위에 속하는 힙과 메소드 영역은 JVM이 시작될 때 생성되고, JVM이 종료될 때 소멸되며, JVM하나에 힙 하나 메소드 영역도 하나가 생성된다.</strong>
마찬가지로 <strong>클래스 단위에 속하는 런타임 상수풀은 클래스가 생성/ 소멸될 때 함께 생성/소멸되며, 클래스 하나에 런타임 상수풀도 하나가 생성된다.</strong> 스레드 단위에 속하는 PC 레지스터, JVM 스택, 네이티브 메소드 스택도 스레드가 생성/소멸될 때 함께 생성/소멸되며, <strong>스레드 하나에 PC레지스터, JVM 스택, 네이티브 메소드 스택도 하나씩 생성된다.</strong>

<h2>실제 동작 과정</h2>

//힙에서 객체가 생성되는 것을 확인하기 위해 Hello 인스턴스를 만들고 무한루프로 프로그램의 종료를 일부러 막아둔 코드

~~~
public class Hello {
    public static void main(String[] args) {
        final Hello hello = new Hello();
        System.out.println(hello.helloMessage());
        while(true) {}
    }
}
~~~

<h3>JVM 실행</h3>

**java 명령어가 실행되면 JRE가 조성되면서 JVM이 실행된다. JVM이 실행되면 JVM 단위로 생성되는 힙과 메소드 영역이 함께 생성된다.**

<h4>Heap</h4>

<strong>힙은 인스턴스화 된 모든 클래스 인스턴스와 배열을 저장하는 공간이며, 모든 JVM 스레드에 공유된다.</strong> 힙에 저장된 객체에 할당된 메모리는 명시적인 방법으로는 절대 회수하지 못하며, 오직 Garbage collector에 의해서만 회수될 수 있다. Hello는 이 시점에서는 아직 인스턴스화 되지 않았으므로 Heap은 비어있다.

<h4>Method Area</h4>

메소드 영역은 런타임 상수 풀, 필드와 메소드 데이터, 생성자 및 메소드의 코드 내용을 저장한다. 바이트 코드에는 런타임 상수 풀이 아니라 그냥 상수 풀이 포함된다. <strong>런타임 상수 풀은 이 상수 풀을 바탕으로 런타임에, 더 구체적으로는 메소드 영역에 저장될 때 만들어진다.</strong> Hello는 이 시점에 아직 생성되지 않았으므로 메소드 영역도 비어있다.

**JVM 스펙은 런타임 데이터 영역을 6가지로 나눠서 설명하고 있고, 그에 따라 그림에서도 힙과 메소드 영역을 분리해서 표현했지만, 스펙에는 메소드 영역이 논리적으로 힙의 일부지만(따라서 가비지 컬렉션의 대상이 되지만), 메소드 영역의 위치에 대해 강제하지 않는다고 나와있으며, 메소드 영역의 위치는 JVM 구현체에 따라 달라질 수 있다.**

<h3>시작 클래스 생성</h3>

시작 클래스는 Hello를 지칭하며, 시작 클래스를 생성하는 것은 파일 시스템에 있는 Hello.class 파일을 JVM의 메소드 영역으로 읽어들이는 것을 의미한다. 따라서 이 시점에서 Hello의 바이트 코드 내용이 메소드 영역에 저장된다.

<h4>런타임 상수 풀</h4>

클래스가 생성되면 런타임 상수 풀도 함께 생성된다고 했다. <strong>런타임 상수 풀에는 컴파일 탕미에 이미 알 수 있는 리터럴 값부터 런타임에 해석되는 메소드와 필드의 참조까지를 포괄하는 여러 종류의 상수가 포함된다.</strong> 런타임 상수 풀은 다른 전통적인 언어에서 말하는 심볼 테이블과 비슷한 기능을 한다고 보면된다.

![RuntimeConstantPool](images/RuntimeConstantPool.png)


<h3>링크</h3>

링크는 클래스나 인터페이스의 바로 위 수퍼클래스나 수퍼인터페이스, 또는 배열일 경우 배열의 원소인 클래스나 인터페이스를 확인(verify)/준비(prepare)하고, 심볼릭 참조를 해석(resolve)하는 과정을 말한다.

<h4>확인(Verify)</h4>

확인(Verification)은 클래스나 인터페이스의 바이너리 표현이 구조적으로 올바른지를 보장해주는 과정이다. 확인 과정은 다른 클래스나 인터페이스의 로딩을 유발할 수도 있지만, 로딩된 다른 클래스나 인터페이스의 확인이나 준비를 필수적으로 유발하지는 않는다. Hello.class 파일은 JDK에 포함된 공식 컴파일러인 javac에 의해 정상적으로 컴파일 됐으므로 구조적으로 올바르다고 갖어하면, 확인 과정에서 Hello의 부모 클래스인 Object 클래스가 로딩된다.

![Verify](images/Verify.png)

<h4>준비(Preperation)</h4>

준비(Preperation)는 클래스나 인터페이스의 정적(static) 필드를 생성하고 기본값으로 초기화하는 과정이다. 준비 과정에서 JVM 코드의 실행을 필요로 하지 않으며 <strong>기본 값이 아닌 특정 값으로 정적 필드를 초기화하는 과정은 준비 과정이 아니라 초기화 과정에서 수행된다.</strong> 스펙에 정의된 기본형 타입의 기본값과 참조형 타입의 기본값은 다음과 같다.

![PrepareDefaultValue](images/PrepareDefaultValue.png)

Hello에는 static field가 없으므로 이 과정에서 특별히 수행되는 것은 없다.

<h4>해석(Resolution)</h4>
<strong>런타임 상수 풀에 있는 심볼릭 참조가 구체적인 값을 가리키도록 동적으로 결정하는 과정</strong>이다. 초기 상태의 런타임 상수풀에 있는 심볼릭 참조는 해석되어져 있지 않다.

<h3>링크의 조건</h3>

JVM 스펙에서는 링크가 언제 수행되어야 하는지 규정하지 않고 유연하게 구현될 수 있는 여지를 주고 있다.

- 클래스나 인터페이스는 링크되기 전에 먼저 완전히 로딩되어야 한다.
- 클래스나 인스턴스는 초기화되기 전에 먼저 완전히 확인되고 준비되어야 한다.
- 링크 관련 에러는 해당 클래스나 인터페이스에 대한 링크를 필요로 하는 행위가 수행되는 시점에 throw되어야 한다.
- 동적으로 계산되는(dynamically-computed) 상수 A에 대한 심볼릭 참조는, A를 참조하는 명령어가 실행되거나, A를 정적 인자로 참조하는 부트스트랩 메소드가 호출되기 전까지는 해석되지 않는다.
- 동적으로 계산되는(dynamically-computed) call site B에 대한 심볼릭 참조는, B를 정적 인자로 참조하는 부트스트랩 메서드가 호출되기 전까지는 해석되지 않는다.

<br/>
<br/>
<strong>해석 시점은 JVM 구현체에 따라 다를 수 있다. 지연(lazy) 링크 전략을 사용하면 클래스나 인터페이스에 포함된 심볼릭 참조는 해당 참조가 실제 사용될 때 개별적으로 해석된다. 반면에 즉시(eager) 링크 전략을 사용하면 클래스나 인터페이스가 확인될 때 모든 심볼릭 참조가 한꺼번에 해석된다. 지연 링크를 사용하면 해석 과정은 클래스나 인터페이스가 초기화 된 후에 실행될 수도 있다.</strong>

1. Object 클래스가 확인(Verify) 과정에서 메소드 영역에 로딩되어 있으므로, 메소드 영역에 저장된 Object 클래스의 바이트코드 내용에서 생성자(<init>)의 위치를 알아낼 수 있고 그 위치를 Methodref jvva/lang/Object."<init>"의 값으로 해석할 수 있다.

![ResolveInit](images/ResolveInit.png)

2. Hello 인스턴스를 만들 때 필요한 Hello 클래스 정보는 이미 메소드 영역에 로딩되어 있으므로, 메소드 영역 내에서 Hello 클래스의 위치를 Class home/efficio/jvm/sample/Hello의 값으로 해석할 수 있다.

![ResolveInit2](images/ResolveInit2.png)

3. Hello의 생성자를 가리키는 Methodref 항목도 초기화해줄 수 있다.

![ResolveInit3](images/ResolveInit3.png)

4. System 클래스는 아직 로딩되어 있지 않으므로 먼저 로딩하고, 확인 후 준비 과정을 거치면서 System 클래스의 정적 필드인 out의 타입인 PrintStream 클래스도 로딩되고 참조형 변수인 out은 기본값인 null로 초기화된다.

![ResolveInit4](images/ResolveInit4.png)

<strong>대략 이런식으로 로딩-링크 과정이 연쇄적으로 수행되면서 메소드 영역이 채워지고, 메소드 영역 내에서 클래스 단위로 생성되는 런타임 상수 풀 안에 있는 심볼릭 참조가 가리키는 값들이 결정된다.</strong>

**단, 이것도 위에 썼듯이 즉시 링크 방식일 떄의 얘기고, 지연 링크를 사용한다면 각 클래스의 초기화가 수행된 이후에 해석 과정이 수행될 수 있다.**

<h3>초기화</h3>

초기화(Initialization)는 클래스 또는 인터페이스 초기화 메소드(class or interface Initialization method)를 실행할 때 수행되는 과정이다. 쉽게 말하면 여기에서 말하는 초기화는 정적 초기화(static initialization)를 말한다고 볼 수 있다.

<h4>초기화 메소드</h4>

초기화 메소드에는 두 가지가 있다.

<h5>인스턴스 초기화 메소드</h5>
인스턴스 초기화 메소드는 자바 언어로 작성되는 생성자에 해당하며, 클래스는 0개 이상의 인스턴스 초기화 메소드를 가진다. 인스턴스 초기화 메소드는 다음의 조건을 모두 충족해야 한다.

- (인터페이스가 아닌) 클래스 안에 정의된다.
- (바이트 코드 상에서) <init>이라는 특수한 이름으로 표현된다.
- 반환 타입은 void이다.

인스턴스 초기화 메소드는 생성자로서 힙에 인스턴스를 생성하는 역할을 담당한다.

<h5>클래스 초기화 메소드(클래스 또는 인터페이스 초기화 메소드)</h5>

<strong>정적 필드를 기본값으로 초기화 하는 것은 링크의 준비 단계에서 수행되고, 정적 필드를 특정 값으로 초기화 하는 것은 초기화 단계에서 수행된다고 했는데 지금 설명하고 있느 이 클래스 또는 인터페이스 초기화 메소드가 실행되는 것이 초기화 단계다.</strong> 지금 설명하고 있는 이 <strong>클래스 또는 인터페이스 초기화 메소드</strong>가 실행되는 것이 초기화 단계다.

<br/>

'클래스 또는 인터페이스 초기화 메소드'는 클래스나 인터페이스에 1개만 존재할 수 있으며, 다음 조건을 모두 충족해야한다.

- 바이트 코드상에서 <clinit>이라는 특수한 이름으로 표현된다.
- 반환 타입은 void이다
- 쉽게 static 블록의 내용을 하나로 합친것이라고 볼 수 있다.

<br/>
<strong>링크 단계 이후 수행되는 초기화란 결국 정적 초기화를 의미한다.</strong>
Hello에는 정적 필드가 없으므로 초기화 과정에서 따로 수행되는 것이 없다. 초기화 과정을 마쳤으면 JVM에 의해 main 메소드가 호출될 차례다.

<h2>main 메소드 호출</h2>

---------------
앞서 설명한 로딩, 링크, 초기화 과정은 바이트코드 내용 기준, 즉 클래스 단위의 정적인 준비를 다뤘는데, main 메소드 호출부터는 실제 프로그램의 동적인 실행이 일어난다. 프로그램이 실행되려면 최소 단위인 스레드가 있어야 한다. JVM이 main 메소드 호출을 위한 main 스레드를 생성한다.
---------------

